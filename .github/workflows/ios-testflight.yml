name: iOS TestFlight

on:
  push:
    branches: [ main, master ]
    paths:
      - "ios/**"
      - "lib/**"
      - "pubspec.yaml"
      - ".github/workflows/ios-testflight.yml"
  workflow_dispatch: {}

jobs:
  ios:
    runs-on: macos-14

    env:
      FLUTTER_VERSION: '3.35.1'
      IOS_BUNDLE_ID: ${{ secrets.IOS_BUNDLE_ID }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      # App Store Connect (keep existing KEY_ID and ISSUER_ID)
      ASC_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      # Provide ONE of the following (the step below accepts any):
      #   ASC_PRIVATE_KEY_B64  (base64 of the raw .p8)
      #   APP_STORE_CONNECT_PRIVATE_KEY (raw multiline .p8 content)
      #   APP_STORE_CONNECT_PRIVATE_KEY_JSON (full JSON string)
      ASC_PRIVATE_KEY_B64: ${{ secrets.ASC_PRIVATE_KEY_B64 }}
      APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
      APP_STORE_CONNECT_PRIVATE_KEY_JSON: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY_JSON }}
      # fastlane match
      MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---- Flutter toolchain first ----
      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: stable
          cache: true

      - name: Precache iOS & fetch packages
        run: |
          set -e
          flutter precache --ios
          flutter pub get

      - name: Export FLUTTER_ROOT
        shell: bash
        run: |
          set -e
          FLUTTER_BIN="$(which flutter)"
          FLUTTER_ROOT="$(cd "$(dirname "$FLUTTER_BIN")/.." && pwd)"
          echo "FLUTTER_ROOT=$FLUTTER_ROOT" >> "$GITHUB_ENV"
          echo "✅ FLUTTER_ROOT=$FLUTTER_ROOT"

      # If Generated.xcconfig was committed from Windows, regenerate it for macOS
      - name: Normalize Generated.xcconfig (Windows path guard)
        run: |
          set -e
          if [ -f ios/Flutter/Generated.xcconfig ] && grep -qi '^FLUTTER_ROOT=c:' ios/Flutter/Generated.xcconfig; then
            echo "Windows path detected in Generated.xcconfig; regenerating..."
            rm -f ios/Flutter/Generated.xcconfig
            flutter pub get
          fi
          test -f ios/Flutter/Generated.xcconfig || (echo "Generated.xcconfig missing after regen" && exit 1)
          echo "✅ ios/Flutter/Generated.xcconfig OK"

      # ---- Ruby / Pods / Fastlane ----
      - name: Install Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: false

      - name: Install gems (cocoapods + fastlane)
        run: |
          set -e
          gem install --no-document cocoapods -v "~> 1.15"
          gem install --no-document fastlane   -v ">= 2.222"
          pod --version
          fastlane --version

      # (Optional) Cache Pods by lockfile hash
      - name: Cache Pods
        uses: actions/cache@v4
        with:
          path: ios/Pods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      # ---- Clean & install Pods in correct order ----
      - name: Reset Pods
        run: rm -rf ios/Pods ios/Podfile.lock

      - name: Pod repo update & install
        working-directory: ios
        run: |
          set -e
          pod repo update
          pod install
          echo "✅ pod install complete"

      # ---- Early sanity build (no signing) to catch Pod/Swift issues ----
      - name: Build iOS (no codesign)
        run: |
          set -e
          flutter build ios --release --no-codesign

      # ---- Create App Store Connect API key file (robust: B64, RAW .p8, or JSON) ----
      - name: Create App Store Connect API key file (robust)
        shell: bash
        env:
          ASC_PRIVATE_KEY_B64: ${{ env.ASC_PRIVATE_KEY_B64 }}
          ASC_PRIVATE_KEY_RAW: ${{ env.APP_STORE_CONNECT_PRIVATE_KEY }}
          ASC_PRIVATE_KEY_JSON: ${{ env.APP_STORE_CONNECT_PRIVATE_KEY_JSON }}
          ASC_KEY_ID: ${{ env.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ env.ASC_ISSUER_ID }}
        run: |
          set -e
          python3 - << 'PY'
          import os, sys, base64, json

          b64 = (os.environ.get("ASC_PRIVATE_KEY_B64") or "").strip()
          raw = (os.environ.get("ASC_PRIVATE_KEY_RAW") or "").strip()
          jsv = (os.environ.get("ASC_PRIVATE_KEY_JSON") or "").strip()
          key_id = os.environ["ASC_KEY_ID"].strip()
          issuer = os.environ["ASC_ISSUER_ID"].strip()

          # If JSON provided, write directly
          if jsv:
            try:
              obj = json.loads(jsv)
              open("AuthKey.json","w").write(json.dumps(obj))
              print("✅ AuthKey.json written from JSON secret")
              sys.exit(0)
            except Exception as e:
              print("Provided APP_STORE_CONNECT_PRIVATE_KEY_JSON is not valid JSON:", e, file=sys.stderr)
              sys.exit(1)

          key_bytes = b""
          if b64:
            try:
              key_bytes = base64.b64decode(b64)
            except Exception as e:
              print("Failed to decode ASC_PRIVATE_KEY_B64:", e, file=sys.stderr)
              sys.exit(1)
          elif raw:
            key_bytes = raw.replace("\r\n", "\n").encode("utf-8")
          else:
            print("No ASC_PRIVATE_KEY_B64, APP_STORE_CONNECT_PRIVATE_KEY, or APP_STORE_CONNECT_PRIVATE_KEY_JSON provided.", file=sys.stderr)
            sys.exit(1)

          # Persist .p8 (optional; useful for debugging locally)
          open("AuthKey.p8","wb").write(key_bytes)
          txt = key_bytes.decode("utf-8", "replace")

          # Escape into JSON (keep literal \n)
          key_escaped = txt.replace("\\", "\\\\").replace('"','\\"').replace("\n", "\\n")
          obj = {
            "key_id": key_id,
            "issuer_id": issuer,
            "key": key_escaped,
            "duration": 1200,
            "in_house": False
          }
          open("AuthKey.json", "w").write(json.dumps(obj))
          print("✅ AuthKey.json created from .p8")
          PY

      # ---- Keychain + match (FIRST run creates certs/profiles; later set readonly:true) ----
      - name: Set up keychain & fetch signing with match
        env:
          MATCH_KEYCHAIN_NAME: build.keychain
          MATCH_KEYCHAIN_PASSWORD: temp_password_123
        run: |
          set -e
          fastlane run create_keychain \
            name:"$MATCH_KEYCHAIN_NAME" \
            password:"$MATCH_KEYCHAIN_PASSWORD" \
            default_keychain:true \
            unlock:true \
            timeout:3600

          if [ -n "${MATCH_GIT_BASIC_AUTHORIZATION}" ]; then
            export MATCH_GIT_BASIC_AUTHORIZATION="${MATCH_GIT_BASIC_AUTHORIZATION}"
          fi

          # FIRST success only: allow creation (readonly:false)
          fastlane run match \
            type:"appstore" \
            app_identifier:"${IOS_BUNDLE_ID}" \
            git_url:"${MATCH_GIT_URL}" \
            readonly:false \
            api_key_path:"AuthKey.json" \
            keychain_name:"$MATCH_KEYCHAIN_NAME" \
            keychain_password:"$MATCH_KEYCHAIN_PASSWORD"

      # ---- Build IPA with fastlane (gym) ----
      - name: Build IPA
        run: |
          set -e
          fastlane run build_app \
            scheme:"Runner" \
            workspace:"ios/Runner.xcworkspace" \
            export_method:"app-store" \
            clean:true \
            include_bitcode:false \
            output_directory:"ios/build" \
            output_name:"BitTracker.ipa" \
            xcargs:"DEVELOPMENT_TEAM=${APPLE_TEAM_ID} PRODUCT_BUNDLE_IDENTIFIER=${IOS_BUNDLE_ID}"
          ls -lah ios/build

      # ---- Upload to TestFlight ----
      - name: Upload to TestFlight
        run: |
          set -e
          fastlane run upload_to_testflight \
            api_key_path:"AuthKey.json" \
            skip_waiting_for_build_processing:true \
            distribute_external:false
          echo "✅ Upload to TestFlight initiated"

      # ---- Keep artifacts (IPA) ----
      - name: Keep artifacts (IPA)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-ipa
          path: ios/build/*.ipa
          if-no-files-found: warn
